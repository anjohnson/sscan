<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
   <title>The SSCAN record v5.16</title>
</head>
<body>
<h1>
The SSCAN record v5.16</h1>
Author: Tim M. Mooney<br>
Based on the scan record, written by Ned D. Arnold.<br>

<p>&nbsp;Advanced Photon Source
<p>&nbsp;Argonne National Laboratory
<p><a NAME="HEADING32-4"></a>
<h1>
1. Introduction</h1>

<hr>The function of the SSCAN record is to move <i>positioners</i> through
a series of positions and record <i>detector</i> data at each of the positions.
The whole sequence of operations is referred to as a <i>scan</i>. After parameters
defining the scan have been initialized and the scan has been told to start, the SSCAN record begins a possibly long and involved sequence of operations normally without further input,
and it notifies any interested clients as the scan progresses, and when the scan is complete. The data are
collected into arrays within the record so that they needn't be written
point by point by a client.
<p>A single SSCAN record supports a one dimensional scan. Several SSCAN records
can be linked together to perform a multi-dimensional scan.  Each SSCAN record can control up to four positioners and acquire
data from up to 74 process variables (70 detector values of type <tt>float</tt> and four positioner readbacks of type <tt>double</tt>) during a scan. Four additional output variables can
be defined to write to other process variables (usually <i>detectors</i>,
and usually to cause them to begin acquiring data) between the positioning phase
and the data acquisition phase. These outputs are called <i>detector triggers</i>.
<p>&nbsp;Typically, the SSCAN record moves motors and records scaler data at
each motor position, but obviously it can also be used for other
purposes. Any controllable device can be scanned through a set of
values while data are recorded from any other process variables.  For example,
one of the positioner process variables could be used to vary the gain
of a detector during a scan.  Therefore, throughout
this document the term <i>positioner</i> should be taken to mean "any PV to which you can write
a number".  Similarly, the term <i>detector trigger</i> typically refers to a PV that will cause data acquisition to begin when it is written to, but could be taken to mean any PV to which you
can write a number.
Finally, the term <i>detector</i> refers to any readable numeric PV.
<p>&nbsp;All of the process variable names used to identify positioners,
detectors, and detector triggers are specified using <i>reassignable links</i>.
This allows a scan to be configured on the fly.

<p><a NAME="HEADING32-12"></a>
<h2>
1.1. A Simple One Dimensional Scan</h2>
In the simplest complete configuration for a one dimensional scan, one
positioner PV name is specified in <tt>P1PV</tt>, the list of positions to visit
is constructed by selecting the scan mode "LINEAR" (<tt>P1SM</tt>), specifying start and end positions (<tt>P1SP</tt> and <tt>P1EP</tt>), specifying whether positioner values are to be
interpreted as absolute or as relative to before-scan values (<tt>P1AR</tt>), and specifying the number of
positions to visit (<tt>NPTS</tt>); one detector-trigger PV name
is specified in <tt>T1PV</tt>, and the value to be written to this PV is
specified in <tt>T1CD</tt>; and one detector (signal) PV name is specified in
<tt>D01PV</tt>.

When you start a scan (by writing a "1" to the <tt>EXSC</tt> field) the SSCAN record commands the positioner to
move to its starting position.  The SSCAN record uses
recDynLinkPutCallback() (a routine in the library recDynLink.c, which normally is
distributed along with the SSCAN record) to tell the positioner to move, and waits for the
resulting callback before moving on to the next step of the scan,
which is to trigger the detector.&nbsp; The detector is also triggered using
a recDynLinkPutCallback() call, and the SSCAN record waits for it to
finish before going on to the next data point.&nbsp; This will continue
until the SSCAN record has completed <tt>NPTS</tt> steps. At the end of the
scan, the SSCAN record has filled in an array of the positions visited (<tt>P1RA</tt>), and
an array of detector values acquired (<tt>D01DA</tt>).

<p><a NAME="HEADING32-16"></a>
<h2>
1.2. Multidimensional Scans</h2>
Multidimensional scans are easy: the outer SSCAN record (which we'll call "scan2") regards the
inner SSCAN record ("scan1") as a detector to be triggered, and each SSCAN record
acquires its own data.  Thus, <tt>scan2.T1PV</tt> is set to <tt>scan1<tt>EXSC</tt></tt>, and
<tt>scan2.T1CD</tt> is set to 1.  In words, scan2 writes a "1" to the "execute scan"
field (<tt>EXSC</tt>) of scan1. <p>&nbsp;To initiate a scan, the scan2 record is
commanded to begin (<tt>scan2.EXSC</tt> is set to "1".) scan2 then commands its
<i>positioners</i> to their previously specified
starting points, and waits for their callbacks. Then scan2
writes to its <i>Detector Trigger</i>, which in this case causes scan1
to begin its own scan. The scan1 record will now go through its entire
programmed scan, acquiring data from its detectors at each point.
<p>&nbsp;When the scan1 record is finished, its callback causes scan2
to continue in its scan procedure -- reading detector values, moving
positioners to new positions, and causing scan1 to execute again.
<p>This approach to configuring multidimensional scan is very
flexible.  Note that scan1 can be executed independently of scan2, so a
complex multidimensional scan can be built and tested one dimension at a time.

<p><a NAME="HEADING32-18"></a>
<h2>
1.3. Client-server Handshaking in Multidimensional Scans</h2>

An outer SSCAN record involved in a multidimensional scan
doesn't know or care that the "detector" it's triggering
is actually another SSCAN record, which is going to do an entire inner scan; the outer
SSCAN record simply triggers what it regards as a detector, and waits
for that detector to complete.  Nor do the inner SSCAN records know that they are
parts of something larger than themselves.  The only piece of code that
has to know a multidimensional scan is occurring is the client that
stores the data.  This client must collect all of the data from each
inner scan before those data are overwritten by the next execution of
that inner scan, because SSCAN records store only one-dimensional
arrays of data.

Clearly, this calls for some handshaking between the client and the
SSCAN records involved in a multidimensional scan.  The SSCAN record
provides two ways to do this:

<p>1) The client notices that an inner SSCAN record has started a scan,
and writes a "1" to the outer SSCAN record's <tt>WAIT</tt> field.  This
prevents the outer SSCAN record from continuing until the client has
read the inner scan's data.  When the client has finished reading the
inner scan's data, it writes a "0" to the outer SSCAN record's <tt>WAIT</tt>
field, allowing the scan to continue.

If there are several clients that want the scan to <tt>WAIT</tt> for them, they
can all write to the <tt>WAIT</tt> field.  Each "1" increments the scan's
wait-count <tt>WCNT</tt> ; each "0" decrements it.  When <tt>WCNT</tt>  reaches zero, the
scan continues.

<p>2) In very fast scans, there might not be time for a client to
notice that an inner scan has started and write that "1" to the outer
scan's <tt>WAIT</tt> field before the inner scan completes and is triggered
again.  In this case, the outer scan can be made automatically to write
a "1" to it's own <tt>WAIT</tt> field whenever it triggers detectors.  It will
do this if its autoWaitCount (<tt>AWCT</tt>) field is set to "1".  In this case,
the client must NOT write another "1" to the outer scan's <tt>WAIT</tt> field,
but must only write "0" to the <tt>WAIT</tt> field to indicate that it is ready
for the scan to continue.

If there are N clients, the autoWaitCount can be set to N, and the scan
will continue only after N "0"s have been written to the <tt>WAIT</tt> field.

The advantage of method (1) is that scans can be performed whether or
not a client is available to write to the <tt>WAIT</tt> field.  The
disadvantage is that the method 1 handshake is not reliable for fast
scans.  The advantage of method (2) is that it absolutely guarantees
the handshake will succeed, no matter how fast the scan goes.  The
disadvantage is that a client must be available to write "0" to the
<tt>WAIT</tt> field.

<p><a NAME="HEADING32-20"></a>
<h2>
1.4. Completion of positioner and detector-trigger operations</h2>
<p>&nbsp;As was mentioned previously, all of the process variable names used to
identify positioners, detectors, and detector triggers are specified using
<i>reassignable links</i>.  These links are implemented differently than standard EPICS
links (e.g., the output link of an analog output record).  SSCAN-record links are
channel-access links implemented with the recDynLink library (originally written by
Marty Kraimer and Ned Arnold, modified to use callbacks and currently maintained by Tim Mooney).  These links perform writes with the channel-access function, <tt>ca_put_callback()</tt>, and expect the callback
function to be called only after all processing caused by the write operation is complete.
For simple positioners and detectors, this is never a problem.  Inidividual records using either <i>synchronous</i> or <i>asynchronous</i> completion strategies (as these terms
are defined in the EPICS
Application Developer's Guide) always satisfy the completion-callback criterion.  Special
records (MOTOR, SCALER, MCA, and SSCAN record) which do not use either synchronous or
asynchronous strategies have been engineered to satisfy the completion-callback criterion
simply by having them refrain from calling recGblFwdLink() (i.e., from firing their Forward
Links) until the operation they started has finished.

<p>&nbsp;If a positioner or detector is implemented with a collection of linked records all of
which individually satisfy the completion-callback criterion, the whole series of records will
also satisfy the criterion <b>if</b> all links in the processing chain started by the sscan
record's write have the attribute PP, and all of the records that process are scan-passive
(i.e., their .SCAN fields are set to "Passive").  Databases that do not satisfy this criterion
can still satisfy the completion-callback criterion very simply: at least one record in the
database must refrain from firing its Forward Link until the operation is finished, and that
record must be either be the record written to, or it must be linked with attribute PP to the record.  The BUSY record was implemented for this purpose.  Using the BUSY record, any sort of processing, even processing that involves an external, non-EPICS processor can esily satisfy the completion-callback criterion.

<p>&nbsp;Database developers should note that a PP link from a record in one crate to a record in another crate will silently be converted to a CA link, which will not satisfy the completion-callback criterion.  In this case, there are two options: the BUSY-record solution, and using
either the SSCAN record or the SWAIT record to make the inter-crate link.  (The SWAIT record is
a variant of the EPICS WAIT record that uses <tt>ca_put_callback()</tt> to implement its output link, just as the SSCAN record does.)  Because only these two record types request and wait for completion callbacks from records they write to, only they can send scan commands to another crate.

<p><a NAME="HEADING32-22"></a>
<h1>
2. Scan Parameters</h1>

<hr>Many options are available to control the execution of a scan. All parameters for a
particular SSCAN record must be configured prior to initiating the scan, as the SSCAN record will not allow most fields to be written to while a scan is in progress.  However, in a multidimensional scan, outer scans can modify the parameters of inner scans, because at the
time an outer SSCAN record is writing to positioners, all inner SSCAN records are idle.
You should use caution in programming such self modifying scans, because clients displaying
and storing multidimensional-scan data may have trouble dealing with parameters
changing during a scan.

In this documentation, many of the SSCAN-record PV's will be listed in tables containing the following informational headings:
<dl>
<dt><b>Field</b></dt>
<dd>The name of the SSCAN-record field</dd>
<dt><b>Summary</b></dt>
<dd>Basic purpose of the field</dd>
<dt><b>Type</b></dt>
<dd>Data type of the field.  If the field is a menu, the menu choices (text strings) are listed
in quotes.  (Don't include the quotes when you write to the field.)  Note that if you write a numeric value to a menu field, the number will be interpreted as an index into the list of menu choices.  The first item in the list has the index 0.</dd>
<dt><b>DCT</b></dt>
<dd>Can this field be modified by database-configuration tools?</dd>
<dt><b>Initial/Default</b></dt>
<dd>Value if the field is not specified in the .db file.  If the field is a menu, the text string will be shown, followed by the corresponding index. </dd>
<dt><b>Read</b></dt>
<dd>Can user read this field?</dd>
<dt><b>Modify</b></dt>
<dd>Is user ever allowed to write to this field?  (Note that the SSCAN record will reject writes to certain otherwise writable fields while a scan is underway.)</dd>
<dt><b>Posted</b></dt>
<dd>If the record should modify the field, will the new value be posted?</dd>
<dt><b>PP</b></dt>
<dd>Does a channel-access write to this field cause the record to process?</dd>
</dl>

<p><a NAME="HEADING32-23"></a>
<h2>
2.0. Global Parameters</h2>

<table BORDER >
<tr>
<th>Field</th>
<th>Summary</th>
<th>Type</th>
<th>DCT</th>
<th>Initial/Default</th>
<th>Read</th>
<th>Modify</th>
<th>Posted</th>
<th>PP</th>
</tr>

<tr>
<td><tt>NPTS</tt></td>
<td>Number of Points&nbsp;</td>
<td>SHORT</td>
<td>Yes</td>
<td>100</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
</tr>

<tr>
<td><tt>MPTS</tt></td>
<td>Maximum Number of Points</td>
<td>SHORT</td>
<td>Yes</td>
<td>100</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
<td>No</td>
</tr>

<tr>
<td><tt>PASM</tt></td>
<td>Positioner After-Scan Mode</td>
<td>Menu ("STAY", "START POS", "PRIOR POS", "PEAK POS", "VALLEY POS", "+EDGE POS",  "-EDGE POS")</td>
<td>Yes</td>
<td>"STAY" (0)</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
<td>No</td>
</tr>

<tr>
<td colspan=9>
PASM allows the user to control where positioners are left after a scan is finished.  Here are the possibilities:
<dl compact>
<dt>"STAY"<dd>Do nothing.  Leave positioners where they were when the last data point was acquired.
<dt>"START POS"<dd>Go the the position of the first data point acquired.
<dt>"PRIOR POS"<dd>Go to the position they occupied prior to the scan.
<dt>"PEAK POS"<dd>Attempt to find the highest point in the data from the detector specified by the REFD field.  If a highest point is found, go to its position, else "STAY".
<dt>"VALLEY POS"<dd>Attempt to find the lowest point in the data from the detector specified by the REFD field.  If a lowest point is found, go to its position, else "STAY".
<dt>"+EDGE POS"<dd>Take the derivative of the REFD data, then do "PEAK POS".
<dt>"-EDGE POS"<dd>Take the derivative of the REFD data, then do "VALLEY POS".
</dl> 
</td>
</tr>

<tr>
<td><tt>REFD</tt></td>
<td>Reference detector for After-Scan mode</td>
<td>SHORT</td>
<td>Yes</td>
<td>1</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
</tr>

<tr>
<td><tt>BSPV</tt></td>
<td>Before-Scan Process Variable link</td>
<td>STRING [40]</td>
<td>Yes</td>
<td>Null</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
</tr>

<tr>
<td><tt>BSNV</tt></td>
<td>BSPV Name Valid</td>
<td>LONG</td>
<td>No</td>
<td>0</td>
<td>Yes</td>
<td>No</td>
<td>Yes</td>
<td>No</td>
</tr>

<tr>
<td><tt>BSCD</tt></td>
<td>Before-Scan Command Data</td>
<td>FLOAT</td>
<td>Yes</td>
<td>1</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
</tr>

<tr>
<td><tt>ASPV</tt></td>
<td>After-Scan Process Variable link</td>
<td>STRING [40]</td>
<td>Yes</td>
<td>Null</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
</tr>

<tr>
<td><tt>ASNV</tt></td>
<td>ASPV Name Valid</td>
<td>LONG</td>
<td>No</td>
<td>0</td>
<td>Yes</td>
<td>No</td>
<td>Yes</td>
<td>No</td>
</tr>

<tr>
<td><tt>ASCD</tt></td>
<td>After-Scan Command Data</td>
<td>FLOAT</td>
<td>Yes</td>
<td>1</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
</tr>


</table>

<p><a NAME="HEADING32-24"></a>
<h2>
2.1. Positioner Parameters</h2>
Each SSCAN record may control up to four <i>positioners</i> that are commanded
to a new <i>desired position</i> after collecting data at each point. The
positioners are defined by typing in an ASCII string that represents the
process variable name of the positioner.
<p>&nbsp;There are three modes for determining the desired value for the
positioner. The desired mode is specified in the <tt>P1SM</tt>-<tt>P4SM</tt>  fields: <tt>Linear</tt>,
<tt>Table</tt>,
and <tt>On-The-Fly</tt>. If a positioner is specified as
<tt>Linear</tt>,
its desired value is determined by using parameters such as start position,
step increment, number of points, and end position (which are explained
below). If a positioner is specified as <tt>Table</tt>, its next position
is found in an array that has been loaded into the record prior to initiating
a scan. If the positioner is specified as <tt>On-The-Fly</tt>, the SSCAN record sends
it to the start position at the beginning of a scan, waits for it to get there, acquires one data point, 
sends the positioner to the end position, and begins acquiring the remaining data points while the
positioner presumably is travelling to the end position.
<P>
Currently, the SSCAN record does not wait for an <tt>On-The-Fly</tt> positioner to arrive at the
end point.  Ideally, the SSCAN record should finish the data-acquisition portion of a scan but not
enter the post-scan phase (sending positioners to after-scan positions, and executing the after-scan link)
until the positioner has declared itself done.  But this is not what is done.<P>

For <i>n</i> in [1..4]:<br>
<table BORDER>
<tr>
<th>Field</th>
<th>Summary</th>
<th>Type</th>
<th>DCT</th>
<th>Initial/Default</th>
<th>Read</th>
<th>Modify</th>
<th>Posted</th>
<th>PP</th>
</tr>

<tr>
<td><tt>P<i>n</i>PV</tt></td>
<td>Positioner <i>n</i> Process Variable ame</td>
<td>STRING [40]</td>
<td>Yes</td>
<td>Null</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
</tr>

<tr>
<td><tt>P<i>n</i>NV</tt></td>
<td>P<i>n</i>PV Name Valid</td>
<td>LONG</td>
<td>No</td>
<td>0</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
</tr>

<tr>
<td><tt>P<i>n</i>SM</tt></td>
<td>Positioner <i>n</i> Step Mode</td>
<td>Menu ("LINEAR", "TABLE", "FLY")</td>
<td>Yes</td>
<td>"LINEAR" (0)</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
</tr>

<tr>
<td><tt>P<i>n</i>AR</tt></td>
<td>Positioner <i>n</i> Absolute/Relative Mode</td>
<td>Menu ("ABSOLUTE", "RELATIVE")</td>
<td>Yes</td>
<td>"ABSOLUTE" (0)</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
</tr>

</table>

<p><a NAME="HEADING32-27"></a>
<h2>
2.2. Linear Mode</h2>
If a positioner's step mode field (<tt>P1SM</tt>) specifies <tt>Linear</tt>, a scan
can be fully defined by three parameters, e.g., the start position (<tt>P1SP</tt>),
the step increment (<tt>P1SI</tt> ), and the number of data points (<tt>NPTS</tt>). A scan
involving <i>N</i> positioners is defined by merely 2<i>N</i>+1 parameters,
since <tt>NPTS</tt> applies to all positioners. For the convenience of interactive
users, and to support channel access clients that define scans differently,
the first positioner can be specified by as many as six parameters: starting
position (<tt>P1SP</tt>), ending position (<tt>P1EP</tt>), center position (<tt>P1CP</tt> ), scan 
width (<tt>P1WD</tt> ), step increments (<tt>P1SP</tt>), and <tt>NPTS</tt>. For the other three positioners,
the same parameters are available minus the <tt>NPTS</tt> field, since that applies
to all. The parameters that pertain to the same positioner are a set. The
record imposes an upper limit (<tt>MPTS</tt>) on <tt>NPTS</tt>. Both <tt>MPTS</tt> and <tt>NPTS</tt> are configured
by the user. The positioner width, configurable in the <tt>P1WD</tt> -<tt>P4WD</tt>  fields,
may be negative.<p>

For <i>n</i> in [1..4]:<br>
<table BORDER>

<tr>
<th>Field</th>
<th>Summary</th>
<th>Type</th>
<th>DCT</th>
<th>Initial/Default</th>
<th>Read</th>
<th>Modify</th>
<th>Posted</th>
<th>PP</th>
</tr>

<tr>
<td><tt>P<i>n</i>SP</tt></td>
<td>Positioner <i>n</i> Starting Point</td>
<td>DOUBLE</td>
<td>Yes</td>
<td>0</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
</tr>

<tr>
<td><tt>P<i>n</i>EP</tt></td>
<td>Positioner <i>n</i> Ending Point</td>
<td>DOUBLE</td>
<td>Yes</td>
<td>0</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
</tr>

<tr>
<td><tt>P<i>n</i>CP</tt> </td>
<td>Positioner <i>n</i> Center Point</td>
<td>DOUBLE</td>
<td>Yes</td>
<td>0</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
</tr>

<tr>
<td><tt>P<i>n</i>WD</tt> </td>
<td>Positioner <i>n</i> Width</td>
<td>DOUBLE</td>
<td>Yes</td>
<td>0</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
</tr>

<tr>
<td><tt>P<i>n</i>SI</tt> </td>
<td>Positioner <i>n</i> Step Increment</td>
<td>DOUBLE</td>
<td>Yes</td>
<td>0</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
</tr>

</table>

<p>Some of these fields can be redundant. For instance, the positioner
width (<tt>P1WD</tt> -<tt>P4WD</tt> ) is simply the distance from the starting position to
the ending position (<tt>P<i>n</i>EP</tt>  - <tt>P<i>n</i>SP</tt> ). The record calculates
redundant parameters for the same set, if the parameters are left undefined.
However, the user can still configure the redundant parameters anyway.

<p>&nbsp;There is no unique prescription for removing inconsistencies among
redundant parameters, and no hard-coded set of preferences among parameters
is likely to please everyone. Therefore, the SSCAN record allows the user
to "freeze" parameters with flags so that they will not be changed by the
record's internal attempts to ensure consistency among the parameter set.
Frozen parameters can be changed by the user and by any other client, but
not by the record. It is the user's responsibility to ensure that frozen
parameters do not prevent freely specifying unfrozen parameters. For example,
if both <tt>P<i>n</i>SI</tt>  and <tt>NPTS</tt> are frozen, changes to <tt>P<i>n</i>WD</tt> 
 will be
rejected. Similarly, if both <tt>P<i>n</i>SP</tt>  and P<i>n</i>CP are frozen, changes
to <tt>P<i>n</i>EP</tt>  and <tt>P<i>n</i>WD</tt> will have no effect. By default, <tt>P<i>n</i>SP</tt> , <tt>P<i>n</i>SI</tt> ,
and <tt>NPTS</tt> are frozen. When the record cannot adjust the parameters to be
consistent, a flag is raised in the alert field (<tt>ALRT</tt>) and a message reported
in the state message field (<tt>SMSG</tt>).
<p>&nbsp;The freeze flag override field (<tt>FFO</tt> ) has two choices: <tt>Use
F-Flags</tt> and <tt>Override</tt>. <tt>Override</tt> causes the current
settings of all the freeze flags to be saved and monitors to be called
for those that have changed. <tt>Use F-Flags</tt> causes the flags saved with the
<tt>Override</tt>
command to be restored if any have changed. Changing the choice of this
field at run-time causes the special record support routines to perform
these actions. So if <tt>Override</tt> is chosen at run-time, then all
current settings are saved, and can be restored at a later time by changing
the <tt>FFO</tt>  field to <tt>Use F-Flags</tt>.<p>

For <i>n</i> in [1..4]:<br>

<table BORDER >
<tr>
<th>Field</th>
<th>Summary</th>
<th>Type</th>
<th>DCT</th>
<th>Initial/Default</th>
<th>Read</th>
<th>Modify</th>
<th>Posted</th>
<th>PP</th>
</tr>

<tr>
<td><tt>FPTS</tt> </td>
<td>Freeze Flag for <tt>NPTS</tt></td>
<td>Menu ("NO", "FREEZE")</td>
<td>Yes</td>
<td>"FREEZE" (1)</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
</tr>

<tr>
<td><tt>FFO</tt> </td>
<td>Freeze Flag Override</td>
<td>Menu ("USE F-FLAGS", "OVERRIDE")</td>
<td>Yes</td>
<td>"USE F-FLAGS" (0)</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
</tr>

<tr>
<td><tt>P<i>n</i>FS</tt></td>
<td>Positioner <i>n</i> Freeze Flag for <tt>P<i>n</i>SP</tt></td>
<td>Menu ("NO", "FREEZE")</td>
<td>Yes</td>
<td>"NO" (0)</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
</tr>

<tr>
<td><tt>P<i>n</i>FE</tt></td>
<td>Positioner <i>n</i> Freeze Flag for <tt>P<i>n</i>EP</tt> </td>
<td>Menu ("NO", "FREEZE")</td>
<td>Yes</td>
<td>"NO" (0)</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
</tr>

<tr>
<td><tt>P<i>n</i>FI</tt></td>
<td>Positioner <i>n</i> Freeze Flag for <tt>P<i>n</i>SI</tt></td>
<td>Menu ("NO", "FREEZE")</td>
<td>Yes</td>
<td>"NO" (0)</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
</tr>

<tr>
<td><tt>P<i>n</i>FC</tt></td>
<td>Positioner <i>n</i> Freeze Flag for <tt>P<i>n</i>CP</tt></td>
<td>Menu ("NO", "FREEZE")</td>
<td>Yes</td>
<td>"NO" (0)</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
</tr>

<tr>
<td><tt>P<i>n</i>FW</tt></td>
<td>Positioner n Freeze Flag for <tt>P<i>n</i>WD</tt></td>
<td>Menu ("NO", "FREEZE")</td>
<td>Yes</td>
<td>"NO" (0)</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
</tr>
</table>

<p>Although this approach may seem to present the user with an overwhelming
number of choices when it comes to linear scans, it should be noted that
by default the user only has to configure <tt>NPTS</tt>, and the starting position
(<tt>P<i>n</i>SP</tt>) and the step increment (<tt>P<i>n</i>SI</tt>) fields for each
positioner in order
to fully define the scan of a positioner. The operator interface (usually
DM, medm or another CA client) need only present the user with these fields.
However, by changing the freeze flags from the defaults and presenting
the user with different fields to fill in, the scan can be defined in a
completely flexible way. The result is that a simple scan can be defined
easily, but advanced users are not limited in flexibility.

<p><a NAME="HEADING32-33"></a>
<h2>
2.3. Table Mode</h2>

In <tt>Table</tt> mode, the user provides the values for the <tt>P<i>n</i>PA</tt> arrays
prior to the start of a scan. These arrays are used only in <tt>Table</tt> mode.<p>

For <i>n</i> in [1..4]:<br>
<table BORDER>
<tr>
<th>Field</th>
<th>Summary</th>
<th>Type</th>
<th>DCT</th>
<th>Initial/Default</th>
<th>Read</th>
<th>Modify</th>
<th>Posted</th>
<th>PP</th>
</tr>

<tr>
<td><tt>P<i>n</i>PA</tt> </td>
<td>Positioner <i>n</i> Position Array</td>
<td>DOUBLE array</td>
<td>No</td>
<td>Null</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
</tr>
</table>

<p><a NAME="HEADING32-35"></a>
<h2>
2.4. Position Verification, Readback Process Variable, and Delta Parameters</h2>
For each positioner, the user may specify a process variable in the <tt>R1PV</tt> -<tt>R4PV</tt> 
fields that corresponds to the actual (or measured) position of the motor.
If this readback field is configured, the SSCAN record will confirm after
each movement that the actual position is within a specified delta to the
desired position. The delta is specified in the <tt>R1DL</tt> -<tt>R4DL</tt>  fields. If the
delta is exceeded, the scan will abort and the record will go into an alarm
state. A text field within the record (<tt>SMSG</tt>) will inform the operator of
the error condition.<p>

For <i>n</i> in [1..4]:<br>
<table BORDER >
<tr>
<th>Field</th>
<th>Summary</th>
<th>Type</th>
<th>DCT</th>
<th>Initial/Default</th>
<th>Read</th>
<th>Modify</th>
<th>Posted</th>
<th>PP</th>
</tr>

<tr>
<td><tt>R<i>n</i>PV</tt> </td>
<td>Readback <i>n</i> Process Variable&nbsp;</td>
<td>STRING [40]</td>
<td>Yes</td>
<td>Null</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
</tr>

<tr>
<td><tt>R<i>n</i>NV</tt></td>
<td>Readback <i>/n</i> Name Valid</td>
<td>LONG</td>
<td>No</td>
<td>0</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
</tr>

<tr>
<td><tt>R<i>n</i>DL</tt> </td>
<td>Readback <i>n</i> Delta&nbsp;</td>
<td>DOUBLE</td>
<td>Yes</td>
<td>0</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
</tr>

</table>
&nbsp;
<p><a NAME="HEADING32-37"></a>
<h2>
2.5. Detector Trigger Process Variables and Command data</h2> If
valid process variable names are entered into the detector trigger
fields (<tt>T1PV</tt>-<tt>T4PV</tt> ) fields, the SSCAN record will write the specified
command data (the floating point numbers <tt>T1CD</tt>-<tt>T4CD</tt> ) to those
process variables between the positioning phase and the data
acquisition phase.  If no detector trigger field contains a valid PV,
the SSCAN record will skip this step and acquire the data immediately.<p>

For <i>n</i> in [1..4]:<br>
<table BORDER >
<tr>
<th>Field</th>
<th>Summary</th>
<th>Type</th>
<th>DCT</th>
<th>Initial/Default</th>
<th>Read</th>
<th>Modify</th>
<th>Posted</th>
<th>PP</th>
</tr>

<tr>
<td><tt>T<i>n</i>PV</tt></td>
<td>Detector Trigger <i>n</i> Process Variable&nbsp;</td>
<td>STRING [40]</td>
<td>Yes</td>
<td>Null</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
</tr>

<tr>
<td><tt>T<i>n</i>NV</tt></td>
<td>Trigger <i>n</i> Name Valid</td>
<td>LONG</td>
<td>No</td>
<td>0</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
</tr>

<tr>
<td><tt>T<i>n</i>CD</tt></td>
<td>Trigger <i>n</i> Command Data</td>
<td>FLOAT</td>
<td>Yes</td>
<td>1</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
</tr>

</table>

&nbsp;
<p><a NAME="HEADING32-38"></a>
<h2>
2.6. Delay variables</h2> Generally, after the SSCAN record has written to positioners and
waited for all positioners to declare themselves done, it waits an additional settling time,
specified in seconds by the <tt>PDLY</tt> field, before entering the next scan phase.
Similarly, after detector triggers have declared themselves done, the SSCAN record waits
for <tt>DDLY</tt> seconds before reading positioner and detector data.

If no positioners are defined, then <tt>PDLY</tt> is ignored.  If no detector triggers are
defined, then <tt>DDLY</tt> is ignored.  <tt>PDLY</tt> does not apply to after-scan positioner
motions.

&nbsp;
<p><a NAME="HEADING32-39"></a>
<h2>
2.7. Client handshaking variables</h2>
Immediately before data are to be read from positioners and detectors, the SSCAN record checks
the <tt>WCNT</tt> field.  If this field is nonzero, the SSCAN record waits until it gets set to
zero before reading data and continuing with the scan.  The <tt>WCNT</tt> is not directly writable
by clients.  Instead, a client wanting to put a hold on the scan writes a "1" to the <tt>WAIT</tt>
field, which increments <tt>WCNT</tt> by one.  When the client is ready for the scan to continue,
it writes a "0" to the <tt>WAIT</tt> field, which decrements the <tt>WCNT</tt> field.  This mechanism allows
several clients independently to handshake with the SSCAN record, and it is intended or two purposes:
<P>1) In a multidimensional scan, a data-storage client can put a hold on scan2 while it is writing data from scan1.
<P>2) A data-acquisition client that can't or doesn't want to declare completion via EPICS' putNotify mechanism
can declare completion using <tt>WAIT</tt>.

<P>A client may not be able to write quickly enough to <tt>WCNT</tt> to ensure that
the scan holds before data acquisition.  In this case, the client can cause the SSCAN record to write
automatically to <tt>WCNT</tt> whenever detectors are triggered, by incrementing the value of the
<tt>AWCT</tt> field.  The client must remember to decrement <tt>AWCT</tt> before exiting, otherwise
scans will hang waiting for a nonexistent client.

<table BORDER>
<tr>
<th>Field</th>
<th>Summary</th>
<th>Type</th>
<th>DCT</th>
<th>Initial</th>
<th>Read</th>
<th>Modify</th>
<th>Posted</th>
<th>PP</th>
</tr>

<tr>
<td><tt>WAIT</tt></td>
<td>Wait for client</td>
<td>SHORT</td>
<td>No</td>
<td>0</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
</tr>

<tr>
<td><tt>WCNT</tt></td>
<td>Wait count</td>
<td>SHORT</td>
<td>No</td>
<td>0</td>
<td>Yes</td>
<td>No</td>
<td>Yes</td>
<td>No</td>
</tr>

<tr>
<td><tt>AWCT</tt></td>
<td>Auto Wait</td>
<td>SHORT</td>
<td>No</td>
<td>0</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
</tr>

<tr>
<td><tt>WTNG</tt></td>
<td>Waiting</td>
<td>SHORT</td>
<td>No</td>
<td>0</td>
<td>Yes</td>
<td>No</td>
<td>Yes</td>
<td>No</td>
</tr>

</table>

<p><a NAME="HEADING32-40"></a>
<h1>
3. Data Acquisition Parameters</h1>

<hr>Each SSCAN record can acquire data from up to 89 process variables
(70 detector signals <tt>D01</tt>-<tt>D70</tt>; 15 additional detector signals,
<tt>D1</tt>-<tt>DF</tt>, which
are supported only for backward compatibility with previous versions of the
record; and four positioner readbacks, <tt>R1</tt>-<tt>R4</tt>) at each point in the scan. These
data will most commonly be from a detector or from a position readback (which
would record the actual motor positions at each point and could then be compared
to the desired position array).  Although positioner readbacks are normally used
to confirm the position at which data actually were acquired (as opposed to the
position to which the SSCAN record <i>told</i> a positioner to go), they can
be used to record any data.  These four variables are the only place to record
double-precision scan data.

<p>&nbsp;The scan results will most frequently be read as position
arrays (<tt>P1RA</tt>-<tt>P4RA</tt> ), which are mentioned above, and arrays of detector
data (<tt>D01DA</tt>-<tt><tt>D70DA</tt></tt>, <tt>D1DA</tt>-<tt>DFDA</tt>) where each detector data element
corresponds to the position element.&nbsp; For backward compatibility
with previous versions of the SSCAN and scan records, the SSCAN record
maintains 15 detectors <tt>D1</tt> through <tt>DF</tt>.&nbsp; These fields are expected
to go away someday.

<p>&nbsp;A one-dimensional scan is complete when the
<tt><tt>BUSY</tt></tt> field goes back to zero (during the scan its value is 1).
A client program monitoring the scan can
read the position and data arrays when the <tt>DATA</tt>
field is set to 1. (The client could have a monitor set on the data-array
fields so the record will post them when the scan is finished.)

<p>For two-dimensional scans, the client should read the
arrays from the scan1 record after the completion of each inner scan and
associate these data with the current outer-scan information.  (Let's call
the inner scan 'x', and the outer scan 'y'.)  This will allow
the client to display data after each x scan. The SSCAN
record will buffer the data for only one x scan, so the client
must read the arrays before the next x scan is completed.  If the scan
is too fast for this, the application program can write a 1 to the <tt>WAIT</tt>
field of the scan2 record when the x scan starts.  This will cause
scan2 to <tt>WAIT</tt> for the client before triggering the next x scan.  The
client shows that it's ready for the new scan by writing a 0 to
scan2's <tt>WAIT</tt> field.  If scans are too fast even for this, you can
arrange for scan2 to set its own <tt>WAIT</tt> field for you whenever it starts
an x scan.  You can do this by setting scan2's AWCT (auto-wait count)
to 1.  If you have done this, you <b>must</b> write a 0 to scan2's <tt>WAIT</tt> field
after every x scan, because the scan will <tt>WAIT</tt> indefinitely or this to occur.
You can see whether scan2 is waiting for a client by looking at its <tt>WCNT</tt>  field.

<p>On slow scans, the application program may want to see that the scan
is processed on a point by point basis. Therefore, the SSCAN record
will post monitors on fields that it updates each point, but it will
not post monitors faster than 20 times per second. If a scan is
proceeding at a rate less than 20 points per second, every point will
be posted. If a scan is proceeding at 100 steps per second, scalar
values will be posted every 5th point (approx.). In either case, the
array data will contain every point at the completion of the scan. It
is not recommended that a client use the point to point
data except for keeping the operator aware of the progress of the
scan.<p>

Special Acquisition Parameters:<br>
<table BORDER >
<tr>
<th>Field</th>
<th>Summary</th>
<th>Type</th>
<th>DCT</th>
<th>Initial/Default</th>
<th>Read</th>
<th>Modify</th>
<th>Posted</th>
<th>PP</th>
</tr>

<tr><td colspan=9>version 5.16 and earlier:</td></tr>

<tr>
<td><tt>ACQM</tt></td>
<td>Acquisition Mode</td>
<td>Menu ("NORMAL", "ACCUMULATE", "ADD TO PREV", "GET ARRAYS")</td>
<td>Yes</td>
<td>"NORMAL" (0)</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
</tr>

<tr><td colspan=9>version 5.17 and later:</td></tr>

<tr>
<td><tt>ACQM</tt></td>
<td>Acquisition Mode</td>
<td>Menu ("NORMAL", "ACCUMULATE", "ADD TO PREV")</td>
<td>Yes</td>
<td>"NORMAL" (0)</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
</tr>
<tr>
<td><tt>ACQT</tt></td>
<td>Acquisition Type</td>
<td>Menu ("SCALAR", "1D ARRAY")</td>
<td>Yes</td>
<td>"SCALAR" (0)</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
</tr>
</table>

<p>Data and Execution Flags:<br>
<table BORDER>
<tr>
<th>Field</th>
<th>Summary</th>
<th>Type</th>
<th>DCT</th>
<th>Initial/Default</th>
<th>Read</th>
<th>Modify</th>
<th>Posted</th>
<th>PP</th>
</tr>

<tr>
<td colspan=9>For <i>nn</i> in [01..70] (e.g., "D01PV", "D02PV", ... "D70PV") :</td>
</tr>

<tr>
<td><tt>D<i>nn</i>PV</tt></td>
<td>data <i>nn</i> Process Variable name</td>
<td>STRING [40]</td>
<td>Yes</td>
<td>Null</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
</tr>

<tr>
<td><tt>D<i>nn</i>NV</tt></td>
<td>data <i>nn</i> Name Valid</td>
<td>LONG</td>
<td>No</td>
<td>0</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
</tr>

<tr>
<td><tt>D<i>nn</i>DA</tt></td>
<td>Detector <i>nn</i> data Array</td>
<td>FLOAT[ ]</td>
<td>No</td>
<td>Null</td>
<td>Yes</td>
<td>No</td>
<td>Yes</td>
<td>No</td>
</tr>

<tr>
<td><tt>EXSC</tt></td>
<td>Execute Scan Flag</td>
<td>SHORT</td>
<td>No</td>
<td>0</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
</tr>

<tr>
<td><tt>XSC</tt></td>
<td>Internal copy of <tt>EXSC</tt></td>
<td>SHORT</td>
<td>No</td>
<td>0</td>
<td>Yes</td>
<td>No</td>
<td>Yes</td>
<td>No</td>
</tr>

<tr>
<td><tt>BUSY</tt></td>
<td>Scan-is-busy Flag</td>
<td>SHORT</td>
<td>No</td>
<td>0</td>
<td>Yes</td>
<td>No</td>
<td>Yes</td>
<td>No</td>
</tr>

<tr>
<td><tt>DATA</tt></td>
<td>Data-are-ready flag</td>
<td>SHORT</td>
<td>No</td>
<td>0</td>
<td>Yes</td>
<td>No</td>
<td>Yes</td>
<td>No</td>
</tr>

</table>

<p><a NAME="HEADING32-46"></a>
<h1>
4. Operator Display Parameters</h1>

<hr>Prior to beginning an actual scan, the record can be commanded to
check the scan parameters to ensure that all positioner requests are
within reasonable limits. This is done by writing "1" to the <tt>CMND</tt>
field. The record will do a "dry run" by calculating every positioner
value (or looking it up in the table) and comparing it with the high
range and low range values (<tt>P1HR</tt>-<tt>P4HR</tt> and <tt><tt>P1LR</tt></tt>-<tt>P4LR</tt>) associated with
that positioner's Process Variable. (Drive limits are an attribute of
most process variables).  If any step would exceed the drive limits,
the operator is notified via the <tt>SMSG</tt> field.

<p>&nbsp;Other than that, the High Range and Low Range value fields are
only used as the display limits for an operator interface. The same is
true for the rest of these fields, which are configured to affect the information
displayed to the operator. Each positioner and the detector for each positioner
have the following fields:
<ul>
<li>
An Engineering Units Field (<tt>P1EU</tt>-<tt><tt>P4EU</tt></tt>, <tt>D01EU</tt>-<tt>D70EU</tt>), which has a string
that is given to it by the user.</li>
<li>
A Precision Field (<tt>P1PR</tt>-<tt>P4PR</tt>, <tt>D01PR</tt>-<tt>D70PR</tt>), which holds an integer that
controls the decimal precision that the corresponding field is displayed
with. For instance, <tt>P1PR</tt> controls the decimal precision for positioner
1 array elements.</li>
</ul>
See the EPICS Record Reference Manual for more on the record name (<tt>NAME</tt>) and description
(<tt>DESC</tt>) fields.<p>

<table BORDER>
<tr>
<th>Field</th>
<th>Summary</th>
<th>Type</th>
<th>DCT</th>
<th>Initial/Default</th>
<th>Read</th>
<th>Modify</th>
<th>Posted</th>
<th>PP</th>
</tr>

<tr>
<td colspan=9> For <i>n</i> in [1..4]:</td>
</tr>

<tr>
<td><tt>P<i>n</i>EU</tt></td>
<td>Positioner <i>n</i> Eng. Units</td>
<td>STRING [16]</td>
<td>Yes</td>
<td>16</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
</tr>

<tr>
<td><tt>P<i>n</i>HR</tt></td>
<td>Pos. <i>n</i> High Range</td>
<td>DOUBLE</td>
<td>Yes</td>
<td>0</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
</tr>

<tr>
<td><tt><tt>P<i>n</i>LR</tt></tt></td>
<td>Pos. <i>n</i> Low Range</td>
<td>DOUBLE</td>
<td>Yes</td>
<td>0</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
</tr>

<tr>
<td><tt>P<i>n</i>PR</tt></td>
<td>Pos. <i>n</i> Precision</td>
<td>SHORT</td>
<td>Yes</td>
<td>0</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
</tr>

<tr>
<td colspan=9> For <i>nn</i> in [01..70]:</td>
</tr>

<tr>
<td><tt>D<i>nn</i>EU</tt></td>
<td>Detector <i>nn</i> Eng. Units</td>
<td>STRING [16]</td>
<td>Yes</td>
<td>16</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
</tr>

<tr>
<td><tt>D<i>nn</i>HR</tt></td>
<td>Det. <i>nn</i> High Range</td>
<td>DOUBLE</td>
<td>Yes</td>
<td>0</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
</tr>

<tr>
<td><tt>D<i>nn</i>LR</tt></td>
<td>Det. <i>nn</i> Low Range</td>
<td>DOUBLE</td>
<td>Yes</td>
<td>0</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
</tr>

<tr>
<td><tt>D<i>nn</i>PR</tt></td>
<td>Det. <i>nn</i> Precision</td>
<td>SHORT</td>
<td>Yes</td>
<td>0</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
</tr>

<tr>
<td><tt>NAME</tt></td>
<td>Record Name</td>
<td>STRING [29]</td>
<td>Yes</td>
<td>0</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
<td>No</td>
</tr>

<tr>
<td><tt>DESC</tt></td>
<td>Description</td>
<td>STRING [29]</td>
<td>Yes</td>
<td>Null</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
</tr>
</table>

<p><a NAME="HEADING32-52"></a>
<h1>
5. Run-time Parameters</h1>

<hr>These fields are used to process the record, to implement monitors
for certain fields, and/or to keep track of data for processing and/or
for the operator. None of these fields are configurable by a database configuration
tool. Most of them can be accessed at run-time, and many can be modified
at run-time.
<p>&nbsp;The Code Version (<tt>VERS</tt>) field reflects the version of SSCAN record
processing routines.
<p>&nbsp;The <tt>VAL</tt> field is not used.
<p>&nbsp;The State Message (<tt>SMSG</tt>) field holds a message sent by the record
that alerts the operator to an error condition. It can be cleared by writing
a 0 to the Command (<tt>CMND</tt>) field.
<p>&nbsp;The Alert (<tt>ALRT</tt>) field is a flag which indicates if an error condition
currently exists. 1 means YES; 0, NO. The cause of the condition will be
displayed in the <tt>SMSG</tt> field.
<p>&nbsp;The scan-phase (<tt>FAZE</tt>) field indicates in which phase of a scan the record
currently is.  The possible phases are as follows:
<table border>
<tr><th>phase</th><th>message</th><th>meaning</th></tr>
<tr><td>0</td><td>IDLE</td><td>Nothing is going on.</td></tr>
<tr><td>1</td><td>INIT_SCAN</td><td>A scan is starting</td></tr>
<tr><td>2</td><td>DO:BEFORE_SCAN</td><td>The next thing to do is trigger the before-scan link.</td></tr>
<tr><td>3</td><td>WAIT:BEFORE_SCAN</td><td>The before-scan link has been triggered.  We're waiting for its callback to come in.</td></tr>
<tr><td>4</td><td>MOVE_MOTORS</td><td>The next thing to do is to write to positioners.</td></tr>
<tr><td>5</td><td>WAIT:MOTORS</td><td>We've told motors to move.  Now we're waiting for their callbacks to come in.</td></tr>
<tr><td>6</td><td>TRIG_DETECTORS</td><td>The next thing to do is to trigger detectors.</td></tr>
<tr><td>7</td><td>WAIT:DETECTORS</td><td>We've triggered detectors.  Now we're waiting for their callbacks to come in.</td></tr>
<tr><td>8</td><td>START_FLY</td><td>This is an on-the-fly scan</td></tr>
<tr><td>9</td><td>RETRACE_MOVE</td><td>The next thing to do it send positioners to their post-scan positions.</td></tr>
<tr><td>10</td><td>WAIT:RETRACE</td><td>We've told positioners to go to their post-scan positions.  Now we're waiting for their callbacks to come in.</td></tr>
<tr><td>11</td><td>DO:AFTER_SCAN</td><td>The next thing to do is trigger the after-scan link.</td></tr>
<tr><td>12</td><td>WAIT:AFTER_SCAN</td><td>The after-scan link has been triggered.  We're waiting for its callback to come in.</td></tr>
<tr><td>13</td><td>SCAN_DONE</td><td>The scan in finished.</td></tr>
<tr><td>14</td><td>PREVIEW</td><td>We're doing a preview of the scan.</td></tr>
<tr><td>15</td><td>SCAN_PENDING</td><td>A scan has been commanded, but has not yet started</td></tr>
</table>

<p>The <tt>CMND</tt> field supports six commands, as follows:

<table BORDER >
<tr>
<th><tt>CMND</tt></th> <th>Command</th>
<tr><td>0<td>Clear the State Message field (<tt>SMSG</tt>)</td></tr>
<tr><td>1<td>Execute a "dry run", checking the desired position against the range limits for each positioner</td></tr>
<tr><td>2<td>Check to see if limits would be violated if the currently programmed scan were actually performed</td></tr>
<tr><td>3<td>Clear all PV's, freeze flags, modes, switches, etc.</td></tr>
<tr><td>4<td>Clear all positioner-related PV's, freeze flags, modes, and  switches.</td></tr>
<tr><td>5<td>Clear positioner-name PV's.</td></tr>
</table>
<p>&nbsp;The Current Point (<tt>CPT</tt>) field contains the current point of an
active scan. The Desired Value fields for each positioner (<tt>P1DV</tt>-<tt>P4DV</tt>) contain
the desired value of each positioner for the current point (<tt>CPT</tt>) in the
scan. The Readback Current Value (<tt>R1CV</tt>-<tt>R4CV</tt>) fields contain the current
readback value for each positioner. The Detector Current Value (<tt>D01CV</tt>-<tt>D70CV</tt>)
contain each detector's current value for the current point in the scan.
The event posting for these fields is throttled to 20 Hz, so for fast scans
not every value will be posted.
<p>&nbsp;The <tt>PCPT</tt>, <tt>PXSC</tt>, <tt>P1LV</tt>-<tt>P4LV</tt>, <tt>R1LV</tt>-<tt>R4LV</tt>, and D01LV-D70LV fields all
contain the previous or "last" value for their corresponding fields. For
instance, the <tt>R1LV</tt> field contains the last value for the <tt>R1CV</tt> field. These
fields are used to implement monitors for the corresponding field. For
instance, if <tt>CPT</tt> does not equal <tt>PCPT</tt> when the record is processed, then
monitors are triggered for <tt>CPT</tt>.
<p>&nbsp;The Name Valid fields (<i>xx</i><tt>NV</tt>) are flag fields which indicate
if the corresponding process variable field contains an existing process
variable. For instance, the <tt>P1NV</tt> field indicates whether the <tt>P1PV</tt> field contains a
valid process-variable name; the <tt>R4NV</tt> field indicates whether <tt>R4PV</tt>  contains
a valid PV name, and so on.  If a positioner's PV name field is blank, all other fields associated with that positioner are ignored.  If a PV name field is not empty, but consists purely
of "whitespace" characters (blanks or tabs, say) then the SSCAN record will silently set the
PV name field to the empty string.
<p>&nbsp;The database Address fields (<i>xx</i><tt>DB</tt>) are of normally of interest
only to the record itself, and are not even accessible at run-time. They
contain pointers to the dbAddr structures of the corresponding process
variables. For instance, <tt>P1DB</tt> points to the dbAddr structure of <tt>P1PV</tt>.
<table BORDER >
<tr>
<th>Field</th>
<th>Summary</th>
<th>Type</th>
<th>DCT</th>
<th>Initial/Default</th>
<th>Read</th>
<th>Modify</th>
<th>Posted</th>
<th>PP</th>
</tr>

<tr>
<td><tt>VERS</tt></td>
<td>Code Version</td>
<td>FLOAT</td>
<td>No</td>
<td>1.0</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
<td>No</td>
</tr>

<tr>
<td><tt>VAL</tt></td>
<td>Value Field&nbsp;</td>
<td>DOUBLE</td>
<td>No</td>
<td>0</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
</tr>

<tr>
<td><tt>SMSG</tt></td>
<td>State Message&nbsp;</td>
<td>STRING [40]</td>
<td>No</td>
<td>Null</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
</tr>

<tr>
<td><tt>CMND</tt></td>
<td>Command Field</td>
<td>ENUM</td>
<td>No</td>
<td>0</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
</tr>

<tr>
<td><tt>ALRT</tt></td>
<td>Alert Field&nbsp;</td>
<td>UCHAR</td>
<td>No</td>
<td>0</td>
<td>Yes</td>
<td>No</td>
<td>Yes</td>
<td>No</td>
</tr>

<tr>
<td><tt>RPVT</tt></td>
<td>Record Private&nbsp;</td>
<td>NOACCESS</td>
<td>No</td>
<td>Null</td>
<td>No</td>
<td>No</td>
<td>No</td>
<td>No</td>
</tr>

<tr>
<td><tt>PXSC</tt></td>
<td>Previous Execute Scan</td>
<td>UCHAR</td>
<td>No</td>
<td>0</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
<td>No</td>
</tr>

<tr>
<td><tt>CPT</tt></td>
<td>Current Point</td>
<td>SHORT</td>
<td>No</td>
<td>0</td>
<td>Yes</td>
<td>No</td>
<td>Yes</td>
<td>No</td>
</tr>

<tr>
<td><tt>PCPT</tt></td>
<td>Previous Current Point&nbsp;</td>
<td>SHORT</td>
<td>No</td>
<td>0</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
<td>No</td>
</tr>

<tr>
<td><tt>TOLP</tt></td>
<td>Time of Last Posting&nbsp;</td>
<td>ULONG</td>
<td>No</td>
<td>0</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
<td>No</td>
</tr>

<tr><td colspan=9>For <i>n</i> in [1..4]:</td></tr>

<tr>
<td><tt>P<i>n</i>DV</tt></td>
<td>Pos. <i>n</i> Desired Value</td>
<td>DOUBLE</td>
<td>No</td>
<td>0</td>
<td>Yes</td>
<td>No</td>
<td>Yes</td>
<td>No</td>
</tr>

<tr>
<td><tt>P<i>n</i>LV</tt></td>
<td>Pos. <i>n</i> Last Value</td>
<td>DOUBLE</td>
<td>No</td>
<td>0</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
<td>No</td>
</tr>

<tr>
<td><tt>R<i>n</i>CV</tt></td>
<td>Readback <i>n</i> Current Value</td>
<td>DOUBLE</td>
<td>No</td>
<td>0</td>
<td>Yes</td>
<td>No</td>
<td>Yes</td>
<td>No</td>
</tr>

<tr>
<td><tt>R<i>n</i>LV</tt></td>
<td>Readback <i>n</i> Last Value</td>
<td>DOUBLE</td>
<td>No</td>
<td>0</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
<td>No</td>
</tr>

<tr>
<td><tt>P<i>n</i>DB</tt></td>
<td>Pos. <i>n</i> dbAddr</td>
<td>NOACCESS</td>
<td>No</td>
<td>Null</td>
<td>No</td>
<td>No</td>
<td>No</td>
<td>No</td>
</tr>

<tr>
<td><tt>R<i>n</i>DB</tt></td>
<td>Readback <i>n</i> dbAddr</td>
<td>NOACCESS</td>
<td>No</td>
<td>Null</td>
<td>No</td>
<td>No</td>
<td>No</td>
<td>No</td>
</tr>

<tr><td colspan=9>For <i>nn</i> in [01..70]:</td></tr>

<tr>
<td><tt>D<i>nn</i>CV</tt></td>
<td>Detector <i>nn</i> Current Value</td>
<td>FLOAT</td>
<td>No</td>
<td>0</td>
<td>Yes</td>
<td>No</td>
<td>Yes</td>
<td>No</td>
</tr>

<tr>
<td><tt>D<i>nn</i>LV</tt></td>
<td>Detector <i>nn</i> Last Value</td>
<td>FLOAT</td>
<td>No</td>
<td>0</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
<td>No</td>
</tr>

<tr>
<td><tt>D<i>nn</i>DB</tt></td>
<td>Detector <i>nn</i> dbAddr</td>
<td>NOACCESS</td>
<td>No</td>
<td>Null</td>
<td>No</td>
<td>No</td>
<td>No</td>
<td>No</td>
</tr>


</table>

<p><!-- TOC -->
<dl>
<dt>
<a href="#HEADING32-4"><b>1. </b>- Introduction</a></dt>

<dt>
<a href="#HEADING32-12"><b>1.1. </b>- A Simple One 
Dimensional Scan</a></dt>

<dt>
<a href="#HEADING32-16"><b>1.2. </b>- Multidimensional
Scans</a></dt>

<dt>
<a href="#HEADING32-18"><b>1.3. </b>- Client-server Handshaking in
Multidimensional Scans</a></dt>

<dt><a href="#HEADING32-20"><b>1.4.  </b>- Completion of positioner and detector-trigger operations</a></dt>

<dt>
<a href="#HEADING32-22"><b>2. </b>- Scan Parameters</a></dt>

<dt>
<a href="#HEADING32-23"><b>2.0. </b>- Global Parameters</a></dt>

<dt>
<a href="#HEADING32-24"><b>2.1. </b>- Positioner Parameters</a></dt>

<dt>
<a href="#HEADING32-27"><b>2.2. </b>- Linear Mode</a></dt>

<dt>
<a href="#HEADING32-33"><b>2.3. </b>Table Mode</a></dt>

<dt>
<a href="#HEADING32-35"><b>2.4. </b>- Position Verification,
Readback Process Variable, and Delta Parameters</a></dt>

<dt>
<a href="#HEADING32-37"><b>2.5. </b>- Detector Trigger
Process Variables and Command data</a></dt>

<dt>
<a href="#HEADING32-40"><b>3. </b>- Data Acquisition Parameters</a></dt>

<dt>
<a href="#HEADING32-46"><b>4. </b>- Operator Display Parameters</a></dt>

<dt>
<a href="#HEADING32-52"><b>5. </b>- Run-time Parameters</a></dt>

<dd>
</dd>
</dl>

</body>
</html>
